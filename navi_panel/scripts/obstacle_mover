#!/usr/bin/env python3

from spot_msgs.msg import (ObstacleMoveAction, ObstacleMoveGoal, ObstacleMoveResult, ObstacleMoveFeedback,
                           MultiGraspAction, MultiGraspGoal, MultiGraspResult, MultiGraspFeedback,
                           GripperAction, GripperGoal, GripperResult, GripperFeedback)
from geometry_msgs.msg import Pose, PoseStamped
from std_msgs.msg import Header
from bosdyn.client.math_helpers import SE3Pose as bdSE3Pose
from bosdyn.client.math_helpers import Quat as bdQuat
from scipy.spatial.transform import Rotation as R

import numpy as np
import rospy
import actionlib


# !!! This class is copied from spot_viz/scripts/interactive_marker_utils. There is a TODO comment
# saying to move it to an external library. Once that is done replace this class definition with an import
class SE3Pose(bdSE3Pose):
    '''TODO: move this to a seperate library
    This class is a wrapper around bosdyn.client.math_helpers.SE3Pose.
    It adds functions that are useful for ROS.'''
    def __init__(self, x=0, y=0, z=0, rot=bdQuat(1,0,0,0), 
                 reference_frame=None):
        super().__init__(x, y, z, rot)
        self.ref=reference_frame
    
    @staticmethod
    def from_ros_pose(pose:Pose):
        p = pose.position
        q = pose.orientation
        se3 = SE3Pose(x=p.x, y=p.y, z=p.z,
                rot=bdQuat(x=q.x, y=q.y, z=q.z, w=q.w))
        return se3
    
    def to_ros_pose(self):
        pose = Pose()
        p = pose.position
        p.x, p.y, p.z = self.x, self.y, self.z
        q = pose.orientation
        q.x, q.y, q.z, q.w = self.rot.x, self.rot.y, self.rot.z, self.rot.w 
        return pose
    
    @staticmethod
    def from_matrix(m): 
        return SE3Pose._from_super(bdSE3Pose.from_matrix(m))
    
    def __mul__(self, other): 
        return self._from_super(super().__mul__(other))

    @staticmethod
    def _from_super(s): 
        return SE3Pose(x=s.x, y=s.y, z=s.z, rot=s.rot)


def _get_perpendicular_pose(pose, rot_vec=[0, 0, np.pi / 2], offset=[0.0, 0.0, 0.0]):
    rot = R.from_rotvec(rot_vec)
    quat = pose.orientation
    pose_rot = R.from_quat([quat.x, quat.y, quat.z, quat.w])
    pose_quat = (pose_rot * rot).as_quat()
    quat.x, quat.y, quat.z, quat.w = pose_quat

    print(f'offset: {offset}')
    offset = pose_rot.as_matrix() @ np.array(offset).T
    print(f'pose_rot.as_matrix(): {pose_rot.as_matrix()}')
    p = pose.position
    p.x += offset[0];
    p.y += offset[1];
    p.z += offset[2]
    pose.position = p
    print(pose.position)
    return pose


def main():
    rospy.init_node("obstacle_mover", anonymous=True)

    # state variables
    _feedback = ObstacleMoveFeedback()
    _result = ObstacleMoveResult()

    # helper functions
    def _handle_action(goal):
        rospy.loginfo("Beginning obstacle-move action.")

        # unpack goal variables
        _feedback.feedback = "Unpacking goal fields"
        _server.publish_feedback(_feedback)

        start = goal.obstacle_location
        end = goal.obstacle_destination

        # calculate closest tagged object to obstacle position
        _feedback.feedback = "Calculating closest tagged object to obstacle location estimate"
        _server.publish_feedback(_feedback)

        # TODO implement once multiple tag detection is added
        closest_tag_object = _tags[0]
        if closest_tag_object["pose"] is None:
            rospy.logerr("No pose for apriltag- is the detector running?")
            _result.success = False
            _result.message = "No poses read for apriltag"
            _server.set_aborted(_result)

        # send multigrasp request
        # offset stored in the "tag offset" key of the dictionary must be applied before multigrasp request is sent.
        _feedback.feedback = "Building multigrasp request"
        _server.publish_feedback(_feedback)

        transform = closest_tag_object["tag offset"]
        if isinstance(transform, np.ndarray): converted_transform = SE3Pose.from_matrix(transform)
        elif isinstance(transform, SE3Pose): converted_transform = transform
        pose_transformed = SE3Pose.from_ros_pose(closest_tag_object["pose"]) * converted_transform
        obj_pose = pose_transformed.to_ros_pose()

        poses = [_get_perpendicular_pose(obj_pose, rot_vec=grasp["grasp_R"], offset=grasp["grasp_t"])
                 for grasp in closest_tag_object["grasps"]]
        weights = [grasp["weight"] for grasp in closest_tag_object["grasps"]]

        _feedback.feedback = "Executing multigrasp"
        _server.publish_feedback(_feedback)

        mg_goal = MultiGraspGoal(poses=poses, weights=weights, header=Header(frame_id="odom"))

        _mg_client.send_goal(mg_goal, feedback_cb=rospy.loginfo)
        _mg_client.wait_for_result()
        mg_result = _mg_client.get_result()

        rospy.loginfo(mg_result)

        if mg_result.success is False:
            rospy.logerr("Multigrasp failed")
            _result.success = False
            _result.message = "Failed multigrasp"
            _server.set_aborted(_result)

        # send request to drag to destination pose
        # TODO

        # stow arm(?)
        # TODO

        # send result
        _result.success = True
        _result.message = "Successfully moved obstacle"
        _server.set_succeeded(_result)

    def _handle_tag_pose(msg):
        # PLACEHOLDER till apriltag detector is updated to publish disambiguated tag poses
        # TODO implement once multiple tag detection is added
        # rospy.loginfo("updating tag pose")
        if _tags[0]["pose"] is None:
            rospy.loginfo("Tag pose acquired.")

        _tags[0]["pose"] = msg.pose
        rospy.loginfo(str(_tags[0]["pose"]))

    # subscribers & clients
    _tag_sub = rospy.Subscriber("/tcpu", PoseStamped, _handle_tag_pose)
    rospy.loginfo("Successfully subscribed to tag pose topic")

    rospy.loginfo("Waiting for multigrasp server...")
    _mg_client = actionlib.SimpleActionClient("spot/multigrasp", MultiGraspAction)
    _mg_client.wait_for_server()
    rospy.loginfo(f"Connected to multigrasp server.")

    rospy.loginfo("Waiting for manipulate server...")
    _dg_client = actionlib.SimpleActionClient("spot/manipulate", GripperAction)
    rospy.loginfo("Connected to maniuplate server.")

    # tag array
    # NOTE: two offsets are required to get from the tag pose to the grasp pose. One to transform the tag's pose
    #       to the center of the chair, and one to transform the center of the chair to the grasp position. This
    #       is to maintain compatibility with the grasp offsets used in chair_marker, which allows for offsets to
    #       be tested with Rviz using the interactive marker, then simply copied into here for use in navigation.
    _tags = [
        {
            # Back-of-chair tag
            "id": 5,
            "pose": None,
            "tag offset": np.array([[-1.0,  0.0, 0.0, 0.0],
                                    [0.0,  0.0, -1.0, 0.4],
                                    [0.0, -1.0, 0.0,  0.25]]),
            "grasps": [
                {
                    'name': 'backrest left side',
                    'grasp_t': [0.2, 0.15, 0.6],
                    'grasp_R': [0.0, 2.22144147, 2.22144147],
                    'multigrasp_enabled': True,
                    'weight': 2
                },
                {
                    'name': 'backrest right side',
                    'grasp_t': [-0.2, 0.15, 0.6],
                    'grasp_R': [1.57079632679, 0.0, 0.0],
                    'multigrasp_enabled': True,
                    'weight': 1
                }
            ]
        }
    ]

    # server initialization
    _server = actionlib.SimpleActionServer(
        "/spot/move_obstacle",
        ObstacleMoveAction,
        execute_cb=_handle_action,
        auto_start=False,
    )

    _server.start()

    rospy.loginfo("Spinning obstacle_mover.")

    rospy.spin()


if __name__ == "__main__":
    main()
